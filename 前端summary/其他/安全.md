#web安全
## 攻击类型
 - XSS 跨站脚本攻击
 - CSRF  跨站请求伪造
 - SQL注入
 - 点击劫持
 - 中间人攻击

##XSS
跨站脚本攻击（最常见），攻击者通过注入非法的HTML或JavaScript标签，从而当用户浏览该网页时，控制用户浏览器 
###危害
1. 获取页面数据
2. 获取cookie
3. 劫持前端逻辑
4. 发送请求
5. 偷取网站任意数据
6. 偷取用户资料
7. 偷取用户密码和登陆态
8. 欺骗用户

###分类
- **反射型XSS**
发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务端解析后返回，XSS代码随响应内容一起传回给浏览器，最后浏览器执行XSS代码。这个过程像一次反射，故叫做反射型XSS。
`eg.`<small>一个链接，里面的query字段中包含一个script标签，这个标签的src就是恶意代码，用户点击了这个链接后会先向服务器发送请求，服务器返回时也携带了这个XSS代码，然后浏览器将查询的结果写入Html，这时恶意代码就被执行了。
- **存储型XSS**
攻击者提交一段xss代码后，被服务器接收并存储，所有浏览器访问某个页面都会被xss（浏览器输入标签） 
`eg.`<small>比如攻击者在一篇文章的评论中写入了script标签，这个评论被保存数据库，当其他用户看到这篇文章时就会执行这个脚本。

###防御
（按道理来说只要存在输入数据的地方就可能存在xss危险 ）
- 在cookie中设置httpOnly属性，js脚本将无法读到cookie信息（因为js一般不会去操作cookie，而是在http请求头部直接发送cookie） 
- 前端输入检查格式 
- 后端过滤 

##CSRF
跨站点请求伪造，冒充用户发起请求危害 。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。
1. 用户登录A网站
2. A网站确认身份（给客户端cookie）
3. B网站页面向A网站发起请求（带上A网站身份）

###危害
- 利用已通过认证的用户权限去更新信息 
- 利用已通过认证的用去权限购买商品 
- 利用已通过用户的权限在发表言论 

###防御
- 验证码
	- 强制用户与应用交互 
- SameSite
   - 可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。
- Token验证
   - cookie是发送时自动带上的，而不会主动带上Token，所以在每次发送时主动发送Token
- Referer验证
   - 对于需要防范 CSRF 的请求，请求限制源
- 隐藏令牌
   - 主动在HTTP头部中添加令牌信息


##注入SQL
SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，后台执行SQL语句时直接把前端传入的字段拿来做SQL查询。
###防御
 - 永远不要信任用户的输入。
 - 永远不要使用动态拼装sql
 - 不要把机密信息直接存放
 - **采用sql语句预编译和绑定变量，是防御sql注入的最佳方法**
```javascript
String sql = "select id, no from user where id=?";
        PreparedStatement ps = conn.prepareStatement(sql);
        ps.setInt(1, id);
        ps.executeQuery();
```
##点击劫持
点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。
###防御
 - X-FRAME-OPTIONS
 - JS 防御

####X-FRAME-OPTIONS
`X-FRAME-OPTIONS` 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。

该响应头有三个值可选，分别是
 - `DENY`，表示页面不允许通过`iframe`的方式展示
 - `SAMEORIGIN`，表示页面可以在相同域名下通过`iframe`的方式展示
 - `ALLOW-FROM`，表示页面可以在指定来源的`iframe`中展示

####JS防御
对于某些低版本浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。
```html
<head>
  <style id="click-jack">
    html {
      display: none !important;
    }
  </style>
</head>
<body>
  <script>
    if (self == top) {
      var style = document.getElementById('click-jack')
      document.body.removeChild(style)
    } else {
      top.location = self.location
    }
  </script>
</body>
```
##中间人攻击
中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。

通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。

当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。