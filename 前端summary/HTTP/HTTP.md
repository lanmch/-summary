#网络
##OSI七层协议
 - 应用层 HTTP FTP DHCP DNS
   - 为应用提供通信服务
 - 表示层 
   - 定义数据格式以及加密
 - 会话层 
   - 定义了如何开始、控制、结束一个会话，包括对多个双向消息的控制和管理。
 - 传输层 TCP UDP
   - 选择差错恢复协议还是无差错恢复协议

 - 网络层 IP OSPF开放式最短路径优先 RIP路由信息协议
   - 端到端包传输。
   - 路由选择、包分解成更小的包
 - 数据链路层 PPP
   - 定义单个链路上如何传输数据
 - 物理层
   - 传输介质相关

##DNS
DNS 的作用就是通过域名查询到具体的 IP。

1. 操作系统会首先在本地缓存中查询
2. 没有的话会去系统配置的 DNS 服务器中查询
3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
4. 然后去该服务器查询 google 这个二级域名
5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP

以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。

##前后端如何分离
- 前端专注于：视图层
- 后端专注于：数据访问层
1. 项目设计：项目整体分析，前后端人员共同制定开发接口
2. 项目开发：分工，后端给出接口以及文档
3. 项目测试：API测试交互
4. 项目部署：利用ngnix做反向代理

##前后端通信方式
- ajax
- websocket
- fetch

##AJAX
### 如何创建Ajax
1. 创建XMLHttpRequest对象
2. 设置相应HTTP请求状态变化函数
3. 创建新的HTTP请求并指定方法、URL、同步异步信息
4. 发送HTTP请求
5. 异步调用返回数据
6. js和DOM局部刷新

监听状态（0-4）
0：请求初始化
1：服务器连接已建立
2：请求已接收
3：请求处理中
4：请求完成，响应就绪
```js
var xhr;
if(window.XMLHttpRequest) {
  xhr = new XMLHttpRequest();
} else {
  xhr = new ActiveXObject("Microsoft.XMLHTTP");
}

xhr.onreadystatechange = function() {
  if(xhr.readyState == 4 && xhr.status == 200) {
    dosome(xhr.responseText);
  }
}

xhr.open('GET', "...", "是否异步");
xhr.send();
```

###ajax请求数据如何解释json数据 
说白了就是原生ajax返回的数据格式并不是json而是字符串，而解析这种json格式的字符串有两种方式：
- `eval()`：该方法解析的时候不会去判断字符串是否合法，json对象中的js方法也会被执行（**不推荐**）
- `JSON.parse()`：会检测字符串的合法性

###jsonp和ajax区别
- ajax有同源策略，因此无法跨域访问其他资源（除非使用方法），而jsonp可以跨域访问（也可同源）
- ajax是通过XMLHttpRequest获取数据，而jsonp是通过动态设定script标签获得返回函数的数据

##Websocket
###定义
在单个 TCP 连接上进行全双工通讯的协议。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建**持久性**的连接，并进行**双向**数据传输。

 - Socket.onopen	连接建立时触发
 - Socket.onmessage	客户端接收服务端数据时触发
 - Socket.onerror	通信发生错误时触发
 - Socket.onclose	连接关闭时触发

###websocket与ajax区别
1. 本质不同
 Ajax,即异步JavaScript和XML，是一种创建交互式网页应用的网页开发技术；
 WebSocket是HTML5一种新的协议，实现了浏览器与服务器全双工通信。其本质是先通过HTTP/HTTPS协议进行握手后创建一个用于交换数据的TCP连接，服务端与客户端通过此TCP连接进行实时通信。
2. 生命周期不同。
websocket建立的是长连接，在一个会话中一直保持连接；而ajax是短连接，数据发送和接受完成后就会断开连接。
3. 适用范围不同
websocket一般用于前后端实时数据交互，而ajax前后端非实时数据交互。
4. 发起人不同
Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以相互推送信息。
5. 用法不同

##fetch API
- 最新的ajax解决方案，用于解决古老的XHR对象不能实现的问题
- 优点：语法简单，更加语义化：基于promise实现支持async/await
- 返回的是一个Promise对象
- 参数
	- 第一个参数：URL
	- 第二个参数：options对象，包括method headers body等等

###fetch和ajax区别

fetch请求默认是不带cookie的，需要设置fetch（URL，{credentials:’include’})。 
Credentials有三种参数：same-origin，include，*
服务器返回400 500 状态码时并不会reject，只有网络出错导致请求不能完成时，fetch才会被reject。而ajax只有200或304才算请求成功
fetch是widow的一个方法，基于promise实现；ajax是XMLHttpRequest的一个实例

##CDN
CDN（内容分发网络）是构建在现有互联网基础之上的一层智能虚拟网络，**通过在网络各处部署节点服务器，实现将源站内容分发至所有CDN节点，使用户可以就近获得所需的内容**。CDN服务缩短了用户查看内容的访问延迟，提高了用户访问网站的响应速度与网站的可用性，解决了网络带宽小、用户访问量大、网点分布不均等问题。

**加速原理：**
当用户访问使用CDN服务的网站时，本地DNS服务器通过CNAME方式将最终域名请求重定向到CDN服务。CDN通过一组预先定义好的策略(如内容类型、地理区域、网络负载状况等)，将当时能够最快响应用户的CDN节点IP地址提供给用户，使用户可以以最快的速度获得网站内容。

##SSO
1. 同域下的单点登陆
公司域名a.com 两个页面app1.a.com app2.a.com 登陆站点sso.a.com 登陆后将cookie的域设为顶域a.com（因为设置cookie时只能设置为顶域或自己的域），然后将三个系统的session共享（spring-session）
2. 不同域的单点登陆
流程：
- 用户访问A系统，A系统需要登陆，但是用户现在没有登陆
- 然后跳转至SSO登陆系统，SSO系统也没有登陆，弹出登录页
- 用户填写账号密码，进行SSO系统认证，然后将登陆状态写入SSO的session，浏览器中写入sso域下的cookie
- SSO系统登陆完成后会生成一个 service ticket（类似于登陆凭证），然后跳转到A系统，将servoce ticket作为参数传给A系统
- A系统拿到service ticket，从后台向SSO发送请求验证该service ticket是否有效
- 验证通过后，A系统将登陆状态写入session并且设置A域名下的cookie
- 然后
- 当用户访问B系统时，B系统没有登陆，跳转到SSO系统
- SSO系统已登陆，生成service ticket并跳转到B系统将其传递
- B系统拿到service ticket，通过后台访问SSO，验证有效性
- 验证成功后，B系统将登陆状态写入session并且在B域名下写入cookie
##cookie与session
**区别：** 
- cookie数据存放在客户的浏览器上，session数据放在服务器上。 
- cookie的存储限制了数据量，只允许4KB，而session是无限量的 
- 我们可以轻松访问cookie值但是我们无法轻松访问session，因此它更安全 
###session在服务器的默认有效时间是30分钟
##cookie优缺点
优点：
1. cookie中一班不存放敏感数据，被盗取不会出现重大损失
2. cookie有时效性（生命期），不会永久有效
缺点：
1. cookie有大小长度限制
2. cookie可能被浏览器禁用或者被删除（清除缓存）
##如何删除某个cookie
循环每个cookie设置expiress属性来删除（expiress设置为当前时间，就可立即删除cookie）

##Storage与cookie
###共同点
都是保存在浏览器端，且同源
（安全性问题） 
###不同点
1. cookie无论是否需要，都会在http请求中携带，增加不必要的资源消耗 
2. cookie大小限制一般为4k，并且每个域限定了cookie个数一般为20个，而webstorage一般大小为5m 
3. 数据时效期不同，sessionStorage仅在当前浏览器窗口关闭有效，localStorage始终保存在内存中，cookie需要手
动设置保存 
4. cookie和localstorage在所有同源窗口均可共享，而sessionStorage仅在当前浏览器的当前页面（或者子页面）共享
使用 
5. storage已经被封装好了，可以直接调用，cookie需要自己封装

##cookie常见键值
name/value/expires/path/domain/secure/httpOnly

##二级域名共享cookie
如a.qq.com和b.qq.com
将domain属性设置为顶级域名qq.com

##HTTP和HTTPS
###HTTP
####定义及特点
**定义：**
超文本传输协议，它是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。
**特点：**
- 无连接（限制每次连接只处理一个请求）
- 无状态（协议对于事务处理没有记忆能力）
- 简单快速（客户向服务器请求服务时，只需传送请求方法和路径）
- 灵活（HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记）
####报文结构
请求报文：请求行 + 请求头 + 空行 + 数据
- 请求行：请求方法+URL+http协议（由空格分隔） 
- 请求头（键值对组成） 
- 空行：告诉服务端以下内容不再是请求头 
- 响应报文：状态行+响应头+空行+相应内容 

响应报文：状态行 + 响应头 + 空行 + 响应内容
- 状态行：HTTP协议版本+状态码+状态码描述（空格分隔） 
- 响应头（键值对） 
- 空行：同上 
- 响应内容：返回数据
####方法
 - GET
   - 获取资源
 - POST
   - 传输资源
 - PUT
   - 更新资源
 - DELETE
   - 删除资源
 - HEAD
   - 获取报文首部
####GET和POST区别
- get参数通过url传递，post放在request body中
- get请求会被浏览器主动缓存，而post不会，除非手动设置
- get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留
- get在浏览器回退时是无害的（因为被缓存了），而post会再次请求
- get请求只能进行url编码，而post支持多种编码方式
- get 请求在url中传送的参数有长度限制，而post没有
- 对参数的数据类型，get只接受ascll字符，而post没有限制
- get比post更安全，因为参数直接暴露在url上，所以不能用来传递敏感信息
####HTTP长连接和短连接
- 短连接
	- 客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。
- 长连接Connection:keep-alive
	- 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。
####HTTP长轮询和短轮训
http 长轮询是服务器收到请求后如果有数据, 立刻响应请求; 如果没有数据就会 hold 一段时间, 这段时间内如果有数据立刻响应请求; 如果时间到了还没有数据, 则响应 http 请求;浏览器受到 http 响应后立即发送一个同样 http 请求查询是否有数据;
http端轮询是服务器收到请求不管是否有数据都直接响应 http 请求; 浏览器受到 http 响应隔一段时间在发送同样的 http 请求查询是否有数据;
####HTTP1和HTTP2的区别
- HTTP/2传输采用二进制格式而非文本格式
- HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行
- 使用报头压缩，HTTP/2降低了开销
- HTTP/2让服务器可以将响应主动“推送”到客户端缓存中
###HTTPS
http默认采用80作为通讯端口，对于传输采用不加密的方式，https默认采用443，对于传输的数据进行加密传输。
####HTTPS通信过程
**HTTPS协议 = HTTP协议 + SSL/TLS协议**，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。
**SSL**的全称是Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。
HTTPS为了兼顾安全与效率，**同时使用了对称加密和非对称加密**。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，**对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输**。
####HTTPS四次握手
1. 客户端请求建立SSL链接，并向服务端发送一个随机数和客户端支持的加密方法，比如RSA公钥加密，此时是明文传输。
2. 服务端回复一种客户端支持的加密方法、一个随机数、授信的服务器证书和非对称加密的公钥。
3. 客户端收到服务端的回复后利用服务端的公钥，加上新的随机数通过服务端下发的公钥及加密方法进行加密，发送给服务器。
4. 服务端收到客户端的回复，利用已知的加解密方式进行解密，同时利用前三步生成的随机数通过一定的算法生成HTTP链接数据传输的对称加密key – session key。
###常见对称加密算法和非对称加密算法
非对称：RSA
对称：MD5、DES
###HTTP状态码
`1XX`表示客户端应该继续发送请求 
`2XX`表示请求成功 
`3XX`重定向 
`4XX`客户端错误 
`5XX`服务器错误

**常见状态码：**
- 200表示OK，正常返回信息
- 201表示请求成功且服务器创建了新的资源
- 202表示服务器已经接受了请求，但还未处理
- 301表示永久重定向，请求的网页已经永久移动到新位置
- 302表示临时重定向
- 304表示自从上一次请求以来，页面的内容没有改变过（协商缓存）
- 401表示服务器无法理解请求的格式
- 402表示请求未授权
- 403表示禁止访问
- 404表示请求的资源不存在，一般是路径写错了
- 500表示最常见的服务器错误
- 503表示服务器暂时无法处理请求
##NGNIX
###正向代理与反相代理
**正**
指客户端<->代理->服务端
举个例子：
A（客户端）想租C（服务端）房子，但是A不认识C就租不到。B（代理）认识C能租这个房子，所以A找了B租到折耳根房子
这个过程中C不认识A只认识B，C不知道A租了房子，只知道把房子租给了B
**反**
客户端->代理<->服务端
举个例子：
A（客户端）想租一个房子，B（代理）就把房子租给了他，但是实际上C（服务端）才是房东。B是中介把房子租给了A
这个过程中A不知道这个房子的房东是谁，可能他认为这个房子的房东就B
**区别**
正向代理代理的对象是客户端，反向代理的代理对象是服务端
**总结**
代理服务器站在客户端那边就是正向代理，
代理服务器站在原始服务器那边就是反向代理,
Nginx通过proxy_pass可以设置代理服务。

##TCP与UDP
###TCP
传输控制协议，TCP协议是面向连接的，可靠的，基于字节流的传输协议。
####三次握手与四次挥手
![Alt text](./1552396107467.png)
####为什么不是两次握手
主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。
假设有这样一种场景, 客户端发送的第一个请求连接并且没有丢失，但是被滞留的时间太长。由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送报文。 
而现在第一个请求到达服务端，这个请求已经报废了，但是又会建立连接。

####为什么不是三次挥手
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了
####TCP慢启动与快重传
- 主机开始发送数据报时，如果立即将大量的数据注入到网络中，可能会出现网络的拥塞。慢启动算法就是在主机刚开始发送数据报的时候先探测一下网络的状况，如果网络状况良好，发送方每发送一次文段都能正确的接受确认报文段。那么就从小到大的增加拥塞窗口的大小，即增加发送窗口的大小。
- 快重传算法要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。
####TCP如何保证传输可靠性
- 数据校验与序列号
- 确认应答
- 超时重传
- 拥塞控制（慢启动和快重传）
###UDP
用户数据报协议，无连接、不可靠
###TCP与UDP区别
1. TCP面向连接，UDP不面向连接
2. TCP可靠性较高，UDP可靠性较低
3. TCP传输较慢，UDP传输较快
4. TCP对系统资源要求高，UDP要求低
##从输入URL到页面渲染全过程
总共分为7个步骤：**浏览器中输入域名+域名解析+浏览器与目标服务器建立TCP连接+浏览器通过http协议向目标服务器发送请求+服务器给出响应，将指定文件发送给浏览器+TCP释放链接+浏览器显示页面中所有文本** 
1. 浏览器中输入域名www.baidu.com 
2. 域名解析，先查找浏览器缓存，没有则查找本机HOST缓存，没有再查找路由器缓存，没用就用DNS进行域名解析得到IP地址 
3. 浏览器与目标服务器进行TCP连接，进行TCP三次握手，进行通信 
4. 浏览器通过http协议向目标服务器发送请求（发送的式get请求） 
5. 服务器给出响应，返回文件，由于请求报文头式Content-type：text/html，所以浏览器将返回结果以html的形式渲染 
6. TCP释放连接，四次挥手 
7. 浏览器显示所有文本，对数据包进行渲染
##修改URL但页面不刷新
使用H5 `history`新方法history.pushState(只改变地址栏，不能跨域网址)和history.replaceState（替换地址栏，在历史记录中替换）
##缓存
###定义
浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。
###缓存优点
1. 减少了冗余的数据传输，节省了网费
2. 减少了服务器的负担，大大提升了网站的性能
3. 加快了客户端加载网页的速度
###缓存分类
####**强缓存**
不会向服务器发送请求，直接从缓存中读取资源，返回200的状态码;
####**协商缓存**
向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；
####异同
两者的共同点是，都是从客户端缓存中读取资源；
区别是强缓存不会发请求，协商缓存会发请求。
###强缓存相关字段
`Expires`：表示过期时间，浏览器再次加载资源时，若在这个过期时间内，则命中缓存
`Cache-Control`：
- `max-age：`表示下次能够有效访问缓存资源的相对时间
- `no-cache：`：不使用缓存（个人理解是不缓存过期的资源，缓存会向服务器进行有效处理确认之后处理资源）
- `no-store：`禁用浏览器缓存数据功能

**max-age优先级高于expires**
###协商缓存相关字段
- 浏览器在第一次请求后会返回两个字段：`Last-Modify`和`Etag`
- `Last-Modify`是一个时间标识该资源最后修改的时间
- `Etag`是资源在服务器的唯一标识
- 浏览器在不能强缓存的前提下，会在http请求头部加上`If-Modify-Since`（值为第一次返回的`Last-Modify`）和`If-None-Match`（值为第一次返回的`Etag`）

**ETag和Last-Modified的作用和用法，他们的区别**
- **Etag要优于Last-Modified。**
- Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；
- 在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值；
- 在优先级上，服务器校验优先考虑Etag。
###缓存全过程
1. 浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；
2. 下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求
3. 服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；
4. 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；
###f5与ctrl+f5
f5：这种情况下，实际是浏览器将 cache-control 的 max-age 直接设置成了 0，让缓存立即过期，直接走协商缓存路线。
ctrl+f5：强制刷新的情况下，浏览器会强行设置 no-cache，强制获取最新的资源，就连 if-modified-since 等其他缓存协议字段都会被吃掉。
##跨域
###为什么有跨域
**`同源策略：`**因为安全性问题，所以有同源策略，保护用户的信息安全（你看我们Cookie不是每次都会传给后端咩，那如果其他域名下还可以访问我这个网站的Cookie，还怎么保证数据的安全咧）。
###同源条件
- 同协议
- 同域名（不同子域都不行）
- 同端口。
###方式
####proxy
**proxy代理：**类似于中间人代理，前端在`webpack`加入proxy字段，服务端如`ngnix`在`ngnix.conf`文件里改动`server`的`location`的`proxy_pass`改变为真正请求的api 
####jsonp
浏览器上虽然有同源限制，但是像 `script`标签、`link`标签、`img`标签、`iframe`标签，这种**在标签上通过src地址来加载一些内容的时候浏览器是允许进行跨域请求的**。 

所以JSONP的原理就是：
 - 创建一个script标签，这个script标签的src就是请求的地址（以get方式）；
 - 这个script标签插入到DOM中，浏览器就根据src地址访问服务器资源
 - 请求时需要带一个参数callback=functionName，此时functionName(data)函数接受data就是返回的json数据（如果有多个接口的时候，只需要动态加入script标签即可多级交互嘛） 

####cors
浏览器在请求一个跨域资源的时候，如果是跨域的Ajax请求，他会在请求头中加一个`origin`字段，但他是不知道这个资源服务端是否允许跨域请求的。浏览器会发送到服务端，如果服务器返回的头中没有`'Access-Control-Allow-Origin': '对应网址或 * '` 的话，那么浏览器就会把请求内容给忽略掉，并且在控制台报错

**cors请求分类**
**`简单请求`**
允许的请求方法
 - GET
 - POST 
 - HEAD

HTTP头信息不超出以下字段
- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type
	允许的Content-Type值
	 - text/plain
	 - multipart/form-data
	 - application/x-www-form-ulencoded

对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段（本次请求来自哪个源（协议 + 域名 + 端口））
但是**cors默认不发送cookie**，如果要发送，必须在头部指定字段：`Access-Control-Allow-Credentials: true`，与此同时，ajax请求中必须打开属性`withCredentials`：
`var xhr = new XMLHttpRequest();`
`xhr.withCredentials = true;`

**`非简单请求`**
非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。 
“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段：`Access-Control-Request-Method`（表示所用方法），`Access-Control-Request-Headers`（额外发送的Header）。之后和简单请求过程相似 
